type GraphAccount @entity {
  "Graph account ID"
  id: ID!

  # Staking and Curating and Delegating
  "Curator fields for this GraphAccount. Null if never curated"
  curator: Curator @derivedFrom(field:"account")
  "Indexer fields for this GraphAccount. Null if never indexed"
  indexer: Indexer @derivedFrom(field:"account")
  "Delegator fields for this GraphAccount. Null if never delegated"
  delegator: Delegator @derivedFrom(field:"account")
}

type Subgraph @entity {
  "Subgraph ID - which is derived from the Organization/Individual graph accountID"
  id: ID!
  "Graph account that owns this subgraph"
  owner: GraphAccount!
  "Current version. Null if the subgraph is deprecated"
  currentVersion: SubgraphVersion
  "List of all the subgraph versions included the current one"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraph")
  "Version counter"
  versionCount: BigInt!
}

type SubgraphVersion @entity {
  "Concatenation of subgraph, subgraph deployment, and version ID"
  id: ID!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Subgraph deployment of this version"
  subgraphDeployment: SubgraphDeployment!
  "Version number"
  version: Int!
}

type SubgraphDeployment @entity {
  "Subgraph Deployment ID. The IPFS hash with Qm removed to fit into 32 bytes"
  id: ID!
  "IPFS hash of the subgraph manifest"
  ipfsHash: String!
  "The versions this subgraph deployment relates to"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraphDeployment")
}

type Indexer @entity {
  "Eth address of Indexer"
  id: ID!
  "Graph account of this indexer"
  account: GraphAccount!

  "Active allocations of stake for this Indexer"
  allocations: [Allocation!]! @derivedFrom(field: "activeForIndexer")
  "All allocations of stake for this Indexer (i.e. closed and active)"
  totalAllocations: [Allocation!]! @derivedFrom(field: "indexer")

  "Delegators to this Indexer"
  delegators: [DelegatedStake!]! @derivedFrom(field: "indexer")
}

type Allocation @entity {
  "Channel Address"
  id: ID!
  "Indexer of this allocation"
  indexer: Indexer!
  "Creator of the allocation - can be the operator or the indexer"
  creator: Bytes!
  "If the Allocation is active it shows the indexer. If closed equals null"
  activeForIndexer: Indexer
  "Subgraph deployment that is being allocated to"
  subgraphDeployment: SubgraphDeployment!
}

type Delegator @entity {
  "Delegator address"
  id: ID!
  "Graph account of the delegator"
  account: GraphAccount!
  "Stakes of this delegator"
  stakes: [DelegatedStake!]! @derivedFrom(field: "delegator")
}

type DelegatedStake @entity {
  "Concatenation of Delegator address and Indexer address"
  id: ID!
  "Index the stake is delegated to"
  indexer: Indexer!
  "Delegator"
  delegator: Delegator!
}

type Curator @entity {
  "Eth address of the Curator"
  id: ID!
  "Graph account of this curator"
  account: GraphAccount!
}

type Dispute @entity {
  "Dispute ID"
  id: ID!
  "Subgraph deployment being disputed"
  subgraphDeployment: SubgraphDeployment!
  "Fisherman address"
  fisherman: GraphAccount!
  "Indexer disputed"
  indexer: GraphAccount!
}

# Actions

interface Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later
}

type SubgraphPublishedEvent implements Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  version: SubgraphVersion!

  deployment: SubgraphDeployment!

  "User that triggered the Event"
  account: GraphAccount!
}

type SubgraphMetadataUpdatedEvent implements Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "User that triggered the Event"
  account: GraphAccount!

  ipfsFileHash: String!
}

type SubgraphDeprecatedEvent implements Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "User that triggered the Event"
  account: GraphAccount!
}

type SubgraphNameSignalEnabledEvent implements Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "User that triggered the Event"
  account: GraphAccount!
}

type NSignalMintedEvent implements Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "GraphAccount of the subgraph owner"
  subgraphOwner: GraphAccount!

  curator: Curator!

  curatorAccount: GraphAccount!

  "ID of the corresponding NameSignal entity on the core subgraph"
  nameSignalId: String!

  nameSignal: BigInt!

  versionSignal: BigInt!

  tokens: BigInt!
}

type NSignalBurnedEvent implements Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "GraphAccount of the subgraph owner"
  subgraphOwner: GraphAccount!

  curator: Curator!

  curatorAccount: GraphAccount!

  "ID of the corresponding NameSignal entity on the core subgraph"
  nameSignalId: String!

  nameSignal: BigInt!

  versionSignal: BigInt!

  "Tokens received after burning the NameSignal"
  tokens: BigInt!
}
