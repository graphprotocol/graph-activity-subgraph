type GraphAccount @entity {
  "Graph account ID"
  id: ID!

  # Staking and Curating and Delegating
  "Curator fields for this GraphAccount. Null if never curated"
  curator: Curator @derivedFrom(field: "account")
  "Indexer fields for this GraphAccount. Null if never indexed"
  indexer: Indexer @derivedFrom(field: "account")
  "Delegator fields for this GraphAccount. Null if never delegated"
  delegator: Delegator @derivedFrom(field: "account")
}

type Subgraph @entity {
  "Subgraph ID - which is derived from the Organization/Individual graph accountID"
  id: ID!
  "Graph account that owns this subgraph"
  owner: GraphAccount!
  "Current version"
  currentVersion: SubgraphVersion!
  "List of all the subgraph versions included the current one"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraph")
  "Version counter"
  versionCount: BigInt!

  events: [SubgraphEvent!]! @derivedFrom(field: "subgraph")
}

type SubgraphVersion @entity {
  "Concatenation of subgraph, subgraph deployment, and version ID"
  id: ID!
  "Subgraph of this version"
  subgraph: Subgraph!
  "Subgraph deployment of this version"
  subgraphDeployment: SubgraphDeployment!
  "Version number"
  version: Int!
}

type SubgraphDeployment @entity {
  "Subgraph Deployment ID. The IPFS hash with Qm removed to fit into 32 bytes"
  id: ID!
  "IPFS hash of the subgraph manifest"
  ipfsHash: String!
  "The versions this subgraph deployment relates to"
  versions: [SubgraphVersion!]! @derivedFrom(field: "subgraphDeployment")
}

type Indexer @entity {
  "Eth address of Indexer"
  id: ID!
  "Graph account of this indexer"
  account: GraphAccount!

  "Active allocations of stake for this Indexer"
  allocations: [Allocation!]! @derivedFrom(field: "activeForIndexer")
  "All allocations of stake for this Indexer (i.e. closed and active)"
  totalAllocations: [Allocation!]! @derivedFrom(field: "indexer")

  "Delegators to this Indexer"
  delegators: [DelegatedStake!]! @derivedFrom(field: "indexer")
}

type Allocation @entity {
  "Channel Address"
  id: ID!
  "Indexer of this allocation"
  indexer: Indexer!
  "Creator of the allocation - can be the operator or the indexer"
  creator: Bytes!
  "If the Allocation is active it shows the indexer. If closed equals null"
  activeForIndexer: Indexer
  "Subgraph deployment that is being allocated to"
  subgraphDeployment: SubgraphDeployment!
}

type Delegator @entity {
  "Delegator address"
  id: ID!
  "Graph account of the delegator"
  account: GraphAccount!
  "Stakes of this delegator"
  stakes: [DelegatedStake!]! @derivedFrom(field: "delegator")
}

type DelegatedStake @entity {
  "Concatenation of Delegator address and Indexer address"
  id: ID!
  "Index the stake is delegated to"
  indexer: Indexer!
  "Delegator"
  delegator: Delegator!
}

type Curator @entity {
  "Eth address of the Curator"
  id: ID!
  "Graph account of this curator"
  account: GraphAccount!
}

type Dispute @entity {
  "Dispute ID"
  id: ID!
  "Subgraph deployment being disputed"
  subgraphDeployment: SubgraphDeployment!
  "Fisherman address"
  fisherman: GraphAccount!
  "Indexer disputed"
  indexer: GraphAccount!
}

# Events

interface Event {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later
}

# Subgraph related events

interface SubgraphEvent {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later

  subgraph: Subgraph!
}

interface SubgraphDeploymentEvent {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later

  deployment: SubgraphDeployment!
}

type NewSubgraphPublishedEvent implements SubgraphEvent & SubgraphDeploymentEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  version: SubgraphVersion!

  deployment: SubgraphDeployment!

  "User that triggered the Event"
  accounts: [GraphAccount!]!
}

type NewSubgraphVersionPublishedEvent implements SubgraphEvent & SubgraphDeploymentEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  version: SubgraphVersion!

  deployment: SubgraphDeployment!

  "User that triggered the Event"
  accounts: [GraphAccount!]!
}

type SubgraphMetadataUpdatedEvent implements SubgraphEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "User that triggered the Event"
  accounts: [GraphAccount!]!

  ipfsFileHash: String!
}

type SubgraphDeprecatedEvent implements SubgraphEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "User that triggered the Event"
  accounts: [GraphAccount!]!
}

type SubgraphNameSignalEnabledEvent implements SubgraphEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "User that triggered the Event"
  accounts: [GraphAccount!]!
}

# Profile events (includes Indexer, Curator and Delegator events)

interface GraphAccountEvent {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later

  accounts: [GraphAccount!]!
}

# Indexer events

interface IndexerEvent {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later

  indexer: Indexer!
}

type IndexerServiceRegisteredEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  url: String!

  geoHash: String!
}

type IndexerServiceUnregisteredEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!
}

type DelegationParametersUpdatedEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  indexingRewardCut: Int!

  queryFeeCut: Int!

  cooldownBlocks: Int!
}

type SetOperatorEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  operator: Bytes!

  allowed: Boolean!
}

type IndexerStakeDepositedEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  amount: BigInt!
}

type IndexerStakeLockedEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  amount: BigInt!

  lockedUntil: BigInt!
}

type IndexerStakeWithdrawnEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  amount: BigInt!
}

type IndexerStakeSlashedEvent implements IndexerEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  "Total amount of the indexer stake that was slashed"
  amountSlashed: BigInt!
}

type AllocationCreatedEvent implements IndexerEvent & SubgraphDeploymentEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  "ID of the allocation created"
  allocation: String!

  allocatedAmount: BigInt!

  deployment: SubgraphDeployment!
}

type AllocationCollectedEvent implements IndexerEvent & SubgraphDeploymentEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  "ID of the allocation created"
  allocation: String!

  deployment: SubgraphDeployment!

  collectedQueryFees: BigInt!

  curatorQueryFees: BigInt!
}

type AllocationClosedEvent implements IndexerEvent & SubgraphDeploymentEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  "ID of the allocation created"
  allocation: String!

  deployment: SubgraphDeployment!
}

type RebateClaimedEvent implements IndexerEvent & SubgraphDeploymentEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  accounts: [GraphAccount!]!

  "ID of the allocation created"
  allocation: String!

  deployment: SubgraphDeployment!

  indexerQueryFeeRebates: BigInt!

  delegatorQueryFeeRebates: BigInt!
}

# Curator events

interface CuratorEvent {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later

  curator: Curator!
}

type NSignalMintedEvent implements SubgraphEvent & CuratorEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "GraphAccount of the subgraph owner"
  subgraphOwner: GraphAccount!

  curator: Curator!

  accounts: [GraphAccount!]!

  "ID of the corresponding NameSignal entity on the core subgraph"
  nameSignalId: String!

  nameSignal: BigInt!

  versionSignal: BigInt!

  tokens: BigInt!
}

type NSignalBurnedEvent implements SubgraphEvent & CuratorEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "GraphAccount of the subgraph owner"
  subgraphOwner: GraphAccount!

  curator: Curator!

  accounts: [GraphAccount!]!

  "ID of the corresponding NameSignal entity on the core subgraph"
  nameSignalId: String!

  nameSignal: BigInt!

  versionSignal: BigInt!

  "Tokens received after burning the NameSignal"
  tokens: BigInt!
}

type GRTWithdrawnEvent implements SubgraphEvent & CuratorEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  subgraph: Subgraph!

  "GraphAccount of the subgraph owner"
  subgraphOwner: GraphAccount!

  curator: Curator!

  accounts: [GraphAccount!]!

  "ID of the corresponding NameSignal entity on the core subgraph"
  nameSignalId: String!

  nameSignal: BigInt!

  "Tokens received after burning the NameSignal"
  tokens: BigInt!
}

type SignalMintedEvent implements CuratorEvent & SubgraphDeploymentEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  deployment: SubgraphDeployment!

  curator: Curator!

  accounts: [GraphAccount!]!

  "ID of the corresponding Signal entity on the core subgraph"
  signalId: String!

  versionSignal: BigInt!

  tokens: BigInt!
}

type SignalBurnedEvent implements CuratorEvent & SubgraphDeploymentEvent & GraphAccountEvent & Event @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  deployment: SubgraphDeployment!

  curator: Curator!

  accounts: [GraphAccount!]!

  "ID of the corresponding Signal entity on the core subgraph"
  signalId: String!

  versionSignal: BigInt!

  "Tokens received after burning the NameSignal"
  tokens: BigInt!
}

# Delegator events

interface DelegatorEvent {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  #epoch: Epoch #Probably re-add epoch later

  delegator: Delegator!
}

type DelegatorStakeDepositedEvent implements DelegatorEvent & IndexerEvent & GraphAccountEvent & Event
  @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  delegator: Delegator!

  accounts: [GraphAccount!]!

  tokenAmount: BigInt!

  shareAmount: BigInt!
}

type DelegatorStakeLockedEvent implements DelegatorEvent & IndexerEvent & GraphAccountEvent & Event
  @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  delegator: Delegator!

  accounts: [GraphAccount!]!

  tokenAmount: BigInt!

  shareAmount: BigInt!

  lockedUntil: BigInt!
}

type DelegatorStakeWithdrawnEvent implements DelegatorEvent & IndexerEvent & GraphAccountEvent & Event
  @entity {
  "Generic ID only for uniqueness purposes."
  id: ID!

  timestamp: BigInt!

  blockNumber: BigInt!

  tx_hash: Bytes!

  indexer: Indexer!

  delegator: Delegator!

  accounts: [GraphAccount!]!

  tokenAmount: BigInt!
}
